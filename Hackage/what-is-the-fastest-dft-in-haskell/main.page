---
format: markdown+lhs
title: What is the fastest FFT in Haskell?
...

> import Control.Applicative
> import Control.Monad
> import Criterion.Main
> import System.IO
> import System.Process
> import Text.Printf

> import Solver

> import qualified ClientVectorFFTW

> fromExe :: FilePath -> Solver
> fromExe exeFn prob = do
>   (Just hin, Just hout, _, pid) <- createProcess (proc exeFn [])
>     {std_in = CreatePipe, std_out = CreatePipe}
>   hPutStrLn hin $ printf "%d %f %f %f %f %d %d"
>     (if wisdomFlag prob then 1 else 0::Int)
>     (x1 prob) (x2 prob) (y1 prob) (y2 prob)
>     (probSize prob) (probRepeat prob)
>   hClose hin
>   (ans1: ans2: _) <- map read . words <$> hGetContents hout
>   return (ans1, ans2)

> quarantine :: Solver -> Solver
> quarantine solver prob = do
>   (ans1, ans2) <- solver prob
>   let
>     expectedAns, accuracy :: Double
>     expectedAns = (x2 prob-x1 prob) + f (y1 prob) (y2 prob)
>     f a b = 1/5 - (a+b)/2 + 1/3*(a**2+4*a*b+b**2) - a*b*(a+b) + a**2*b**2
>     rn = fromIntegral $ probSize prob
>     accuracy = max  (rn **(-2)) (1e-16 * rn)
>     passTest x = abs(x-expectedAns) < accuracy
>     pass = all passTest $ [ans1,ans2]
>   when (not pass) $ do
>     hPutStr stderr $ printf
>       "wrong answer! expected %f +- %f, got: %s"
>       expectedAns (show (ans1, ans2))
>   return (ans1, ans2)


> candidates :: [(String, Solver)]
> candidates = [
>   ("cpp", fromExe "./client-fftw-cpp"),
>   ("vector-fftw", ClientVectorFFTW.solver)
>   ]


> main :: IO ()
> main = defaultMain $ (:[]) $ bgroup "fft" $ do
>   n <- map (2^) [10,12..(20::Int)]
>   rep <- [1,101]
>   (tag, solver) <- candidates
>   let prob = Problem{
>         wisdomFlag = False,
>         x1 = 1/4, x2 = 3/4,
>         y1 = 1/3, y2 = 2/3,
>         probSize = n, probRepeat = rep
>       }
>   let tag2 = printf "%s %d %d" tag (probSize prob) (probRepeat prob)
>   return $ bench tag2 $ nfIO $ quarantine solver prob
