---
format: markdown+lhs
title: What is the fastest FFT in Haskell?
...

> import Control.Monad
> import Criterion.Main
> import System.IO
> import System.Process
> import Text.Printf

> makeBenchmark :: FilePath -> Int -> Int -> Benchmark
> makeBenchmark exeFn n iter = bench (printf "%s %d %d" exeFn n iter) $ nfIO $ do
>   (Just hin, Just hout, _, pid) <- createProcess (proc exeFn [])
>     {std_in = CreatePipe, std_out = CreatePipe}
>   let wisdomFlag :: Int
>       x1, x2, y1, y2 :: Double
>       wisdomFlag = 0
>       x1 = 1/4; x2 = 3/4; y1 = 1/3; y2 = 2/3
>   hPutStrLn hin $ printf "%d %f %f %f %f %d %d"
>     wisdomFlag x1 x2 y1 y2 n iter
>   hClose hin
>   ans <- hGetContents hout
>   _ <- waitForProcess pid
>   return ans

> candidates :: [FilePath]
> candidates = ["./client-fftw-cpp"]

> main :: IO ()
> main = defaultMain $ (:[]) $ bgroup "fft" $ do
>   exeFn <- candidates
>   n <- map (2^) [10,12..(20::Int)]
>   iter <- [1,100]
>   return $ makeBenchmark exeFn n iter
